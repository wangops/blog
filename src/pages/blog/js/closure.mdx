
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';


<div className="mdx-box">
#### Javascript 闭包
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包（closure）是指在 JavaScript 中，一个函数和其周围的状态（lexical environment，词法环境）的引用捆绑在一起形成的组合。换句话说，闭包允许函数访问其定义时所处的词法作用域以外的变量。
###### &nbsp;
#### 闭包的特点
###### &nbsp;
####  1. 内部函数可以访问外部函数作用域的变量:
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  在一个函数内部定义另一个函数，内部函数可以访问其外部函数的变量和参数，即使外部函数已经执行完毕。
###### &nbsp;
<SyntaxHighlighter language="javascript">
  {`
        function outerFunction() {
            let outerVariable = 'I am from outer function';

            function innerFunction() {
                console.log(outerVariable); // 内部函数可以访问外部函数的变量
            }

            return innerFunction;
        }

        let closure = outerFunction();
        closure(); // 输出: I am from outer function
    
`}
</SyntaxHighlighter>
###### &nbsp;

####  2. 保持变量的状态： 
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  外部函数执行完毕后，其作用域中的变量不会被销毁，而是被内部函数捕获，可以继续访问和修改这些变量。
###### &nbsp;
<SyntaxHighlighter language="javascript">
  {`
        function counter() {
            let count = 0;

            return function() {
                return ++count;
            };
        }

        let increment = counter();
        console.log(increment()); // 输出: 1
        console.log(increment()); // 输出: 2

    
`}
</SyntaxHighlighter>
###### &nbsp;

####  3. 实现模块化的效果：
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  通过闭包可以创建私有变量和函数，使其不被外部访问，从而实现模块化和封装。
###### &nbsp;
<SyntaxHighlighter language="javascript">
  {`
    let module = (function() {
    let privateVariable = 'I am private';

    function privateFunction() {
        console.log('This is a private function');
    }

    return {
        publicVariable: 'I am public',
        publicFunction: function() {
            console.log('This is a public function');
            privateFunction();
        }
    };
})();

console.log(module.publicVariable); // 输出: I am public
module.publicFunction(); // 输出: This is a public function
                         // 输出: This is a private function


    
`}
</SyntaxHighlighter>
###### &nbsp;

#### 闭包的应用场景：
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  使用闭包可以创建私有变量和方法，防止全局污染。
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  可以实现类似模块化的效果，将一组相关的函数和数据封装在一个作用域内。
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  在异步编程中，闭包可以用来捕获当前的状态，比如事件处理器、回调函数等
###### &nbsp;
#### 注意事项：
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  由于闭包会保留外部函数的作用域，可能会导致内存泄漏，因此在使用闭包时要注意管理内存，避免不必要的变量捕获。
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  可以实现类似模块化的效果，将一组相关的函数和数据封装在一个作用域内。
###### &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;  过度使用闭包可能会影响性能，特别是在循环中创建闭包时，要注意闭包的作用域和生命周期。
###### &nbsp;
闭包在 JavaScript 中是一个非常强大和灵活的概念，合理利用可以帮助我们编写更加模块化、可维护和安全的代码。
###### &nbsp;

</div>




